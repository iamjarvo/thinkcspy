# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012, Peter Wentworth, Jeffrey Elkner, Allen B. Downey and Chris Meyers
# This file is distributed under the same license as the How to Think Like a Computer Scientist: Learning with Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: How to Think Like a Computer Scientist: Learning with Python 3rd Edition\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2012-04-07 17:54\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/variables_expressions_statements.rst:12
# b678c198b82c41e4929dfe7178b3bfac
msgid "Variables, expressions and statements"
msgstr ""

#: ../../source/variables_expressions_statements.rst:23
# 879adb495f9947a6b72ceebfb42edae2
msgid "Values and data types"
msgstr ""

#: ../../source/variables_expressions_statements.rst:25
# 493a4fdb7d4c4c8db2b4349450dc6b5c
msgid "A **value** is one of the fundamental things --- like a letter or a number --- that a program manipulates. The values we have seen so far are ``4`` (the result when we added ``2 + 2``), and ``\"Hello, World!\"``."
msgstr ""

#: ../../source/variables_expressions_statements.rst:29
# da542bb5242a4a2a83e2ceece87e92c3
msgid "These values are classified into different **classes**, or **data types**: ``4`` is an *integer*, and ``\"Hello, World!\"`` is a *string*, so-called because it contains a string of letters. You (and the interpreter) can identify strings because they are enclosed in quotation marks."
msgstr ""

#: ../../source/variables_expressions_statements.rst:35
# 108b4cb6f29b43faa11d9b876ec519ad
msgid "If you are not sure what class a value falls into, Python has a function called **type** which can tell you."
msgstr ""

#: ../../source/variables_expressions_statements.rst:45
# 4c0d2eb483ec4a6ab9b59db24e627755
msgid "Not surprisingly, strings belong to the class **str** and integers belong to the class **int**. Less obviously, numbers with a decimal point belong to a class called **float**, because these numbers are represented in a format called *floating-point*.  At this stage, you can treat the words *class* and *type* interchangeably.  We'll come back to a deeper understanding of what a class is in later chapters."
msgstr ""

#: ../../source/variables_expressions_statements.rst:57
# 9ec53e7ef66f434ba32dd0dc98a0fb5c
msgid "What about values like ``\"17\"`` and ``\"3.2\"``? They look like numbers, but they are in quotation marks like strings."
msgstr ""

#: ../../source/variables_expressions_statements.rst:67
# 241d6dc66309472481797f0d258c9db2
msgid "They're strings!"
msgstr ""

#: ../../source/variables_expressions_statements.rst:69
# e083e50fefab4e4ca473b430d69fb531
msgid "Strings in Python can be enclosed in either single quotes (``'``) or double quotes (``\"``), or three of each (``'''`` or ``\"\"\"``)"
msgstr ""

#: ../../source/variables_expressions_statements.rst:83
# 26e4ad673a7148d49013655343b8ff18
msgid "Double quoted strings can contain single quotes inside them, as in ``\"Bruce's beard\"``, and single quoted strings can have double quotes inside them, as in ``'The knights who say \"Ni!\"'``."
msgstr ""

#: ../../source/variables_expressions_statements.rst:87
# 123069517f804ff085a27bd8f22106be
msgid "Strings enclosed with three occurrences of either quote symbol are called triple quoted strings.  They can contain either single or double quotes:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:97
# 057c8a77b96540d1ae73477ddda23dbb
msgid "Triple quoted strings can even span multiple lines:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:112
# 2fe4e4b022d04d01a2e37bc6968e89eb
msgid "Python doesn't care whether you use single or double quotes or the three-of-a-kind quotes to surround your strings: once it has parsed the text of your program or command, the way it stores the value is identical in all cases, and the surrounding quotes are not part of the value. But when the interpreter wants to display a string, it has to decide which quotes to use to make it look like a string."
msgstr ""

#: ../../source/variables_expressions_statements.rst:126
# 7ebb78365fff44fdb9f1244f107f276b
msgid "So the Python language designers usually chose to surround their strings by single quotes.  What do think would happen if the string already contained single quotes?"
msgstr ""

#: ../../source/variables_expressions_statements.rst:130
# 93f4d1e9909e46a69bb95634e2db047c
msgid "When you type a large integer, you might be tempted to use commas between groups of three digits, as in ``42,000``. This is not a legal integer in Python, but it does mean something else, which is legal:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:141
# 301d58865883482cb5a814527917ca9a
msgid "Well, that's not what we expected at all! Because of the comma, Python chose to treat this as a *pair* of values.  We'll come back to learn about pairs later. But, for the moment, remember not to put commas or spaces in your integers, no matter how big they are. Also revisit what we said in the previous chapter: formal languages are strict, the notation is concise, and even the smallest change might mean something quite different from what you intended."
msgstr ""

#: ../../source/variables_expressions_statements.rst:152
# 6bb8a3ce76e54431a4e92935dfcbff63
msgid "Variables"
msgstr ""

#: ../../source/variables_expressions_statements.rst:154
# 243bb22e7fe4478dbb511766d579861c
msgid "One of the most powerful features of a programming language is the ability to manipulate **variables**. A variable is a name that refers to a value."
msgstr ""

#: ../../source/variables_expressions_statements.rst:157
# 3e236eb0456c4da4950330ae0be0c828
msgid "The **assignment statement** creates new variables and gives them values:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:166
# a0b85dfed18e4fc99ceb0a04b512a1fa
msgid "This example makes three assignments. The first assigns the string value ``\"What's up, Doc?\"`` to a new variable named ``message``. The second gives the integer ``17`` to ``n``, and the third assigns the floating-point number ``3.14159`` to a variable called ``pi``."
msgstr ""

#: ../../source/variables_expressions_statements.rst:171
# d50cf9fe8408463e9f84949df5989583
msgid "The **assignment token**, ``=``, should not be confused with *equals*, which uses the token ``==``.  The assignment statement links a *name*, on the left hand side of the operator, with a *value*, on the right hand side. This is why you will get an error if you enter:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:183
# 52b8cfd53f8b4247b04dcd004c460395
msgid "When reading or writing code, say to yourself \"n is assigned 17\" or \"n gets the value 17\".  Don't say \"n equals 17\"."
msgstr ""

#: ../../source/variables_expressions_statements.rst:187
# 16a0e54a0ce149739feb0816910affb5
msgid "A common way to represent variables on paper is to write the name with an arrow pointing to the variable's value. This kind of figure is called a **state snapshot** because it shows what state each of the variables is in at a particular instant in time.  (Think of it as the variable's state of mind). This diagram shows the result of executing the assignment statements:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:196
# 8cdf0b7ba9fa48a8852629f913ba415e
msgid "If you ask the interpreter to evaluate a variable, it will produce the value that is currently linked to the variable:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:208
# 39efa617c9cb43a28d32e9cd15e82178
msgid "In each case the result is the value of the variable. Variables also have types; again, we can ask the interpreter what they are."
msgstr ""

#: ../../source/variables_expressions_statements.rst:220
# 301f06b0ed204d2cb1c4bf90d51bab6d
msgid "The type of a variable is the type of the value it currently refers to."
msgstr ""

#: ../../source/variables_expressions_statements.rst:222
# 91c5a0dce4d440d48e518a2011da6bce
msgid "We use variables in a program to \"remember\" things, like the current score at the football game. But variables are *variable*. This means they can change over time, just like the scoreboard at a football game. You can assign a value to a variable, and later assign a different value to the same variable. (*This is different from maths. In maths, if you give `x` the value 3, it cannot change to link to a different value half-way through your calculations!*)"
msgstr ""

#: ../../source/variables_expressions_statements.rst:240
# d7b21e591e9d438a94aa8759ccdedccb
msgid "You'll notice we changed the value of ``day`` three times, and on the third assignment we even gave it a value that was of a different type."
msgstr ""

#: ../../source/variables_expressions_statements.rst:243
# 5c4154f3de75496cb66366d6ad023979
msgid "A great deal of programming is about having the computer remember things, e.g. *The number of missed calls on your phone*, and then arranging to update or change the variable when you miss another call."
msgstr ""

#: ../../source/variables_expressions_statements.rst:249
# 00102734494b4a1885b9308d1981ef1d
msgid "Variable names and keywords"
msgstr ""

#: ../../source/variables_expressions_statements.rst:251
# c8ba5304fc6e4446b31ce8a9047aee91
msgid "**Variable names** can be arbitrarily long. They can contain both letters and digits, but they have to begin with a letter or an underscore. Although it is legal to use uppercase letters, by convention we don't. If you do, remember that case matters. ``Bruce`` and ``bruce`` are different variables."
msgstr ""

#: ../../source/variables_expressions_statements.rst:256
# f8ca5741191246aeb99516a83ce64435
msgid "The underscore character ( ``_``) can appear in a name. It is often used in names with multiple words, such as ``my_name`` or ``price_of_tea_in_china``."
msgstr ""

#: ../../source/variables_expressions_statements.rst:259
# 9a80d8189f6d42d28268be0249759e6b
msgid "There are some situations in which names beginning with an underscore have special meaning, so a safe rule for beginners is to start all names with a letter."
msgstr ""

#: ../../source/variables_expressions_statements.rst:262
# d88714f5074940009c55bdbf4434e159
msgid "If you give a variable an illegal name, you get a syntax error:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:273
# c9017c4eab9944b39fc92ca43b71222f
msgid "``76trombones`` is illegal because it does not begin with a letter.  ``more$`` is illegal because it contains an illegal character, the dollar sign. But what's wrong with ``class``?"
msgstr ""

#: ../../source/variables_expressions_statements.rst:277
# 9c6bbe1122384b0cbf367b6d0bce8b8f
msgid "It turns out that ``class`` is one of the Python **keywords**. Keywords define the language's syntax rules and structure, and they cannot be used as variable names."
msgstr ""

#: ../../source/variables_expressions_statements.rst:280
# 195eb2d43b4b47ccbb5bb11b5fd3ad02
msgid "Python has thirty-something keywords (and every now and again improvements to Python introduce or eliminate one or two):"
msgstr ""

#: ../../source/variables_expressions_statements.rst:284
# 3460e9303dfa45f6ac8ab2a632f09049
msgid "and"
msgstr ""

#: ../../source/variables_expressions_statements.rst:284
# 3beba531019443f68d76e2a2a8a1051b
msgid "as"
msgstr ""

#: ../../source/variables_expressions_statements.rst:284
# 74d26abb91ff472383c197c72d57f910
msgid "assert"
msgstr ""

#: ../../source/variables_expressions_statements.rst:284
# 58608f68b03f4ac28a04fb760a9d5778
msgid "break"
msgstr ""

#: ../../source/variables_expressions_statements.rst:284
# 3edeafdc676641368fbf3de8fac29758
msgid "class"
msgstr ""

#: ../../source/variables_expressions_statements.rst:284
# a5bc66dcb49e4f92b03be9cd223c6e4f
msgid "continue"
msgstr ""

#: ../../source/variables_expressions_statements.rst:285
# a63b825e1c08457d9cbee3895eed3f1e
msgid "def"
msgstr ""

#: ../../source/variables_expressions_statements.rst:285
# a30b600b26864a1e80899232518a3c96
msgid "del"
msgstr ""

#: ../../source/variables_expressions_statements.rst:285
# 5d573662087741b0a4820c53c1d7da3f
msgid "elif"
msgstr ""

#: ../../source/variables_expressions_statements.rst:285
# 499115651d3640d9aa188d9966799a15
msgid "else"
msgstr ""

#: ../../source/variables_expressions_statements.rst:285
# 3fd13725e399463fae844df07a69f30c
msgid "except"
msgstr ""

#: ../../source/variables_expressions_statements.rst:285
# 3aebc58ece344f4b96b8eee5d44575de
msgid "exec"
msgstr ""

#: ../../source/variables_expressions_statements.rst:286
# 16d53074c1de4e4ab6b1b35301f981fb
msgid "finally"
msgstr ""

#: ../../source/variables_expressions_statements.rst:286
# a2b78fe5be184f02b29d9854fb9806ab
msgid "for"
msgstr ""

#: ../../source/variables_expressions_statements.rst:286
# f05bc84b200b4ce4aa545168b2c192e0
msgid "from"
msgstr ""

#: ../../source/variables_expressions_statements.rst:286
# 024a15a0a4da4b08a2110d78ba9a2d93
msgid "global"
msgstr ""

#: ../../source/variables_expressions_statements.rst:286
# f928344369fa4a47b9a5bccdbbd50113
msgid "if"
msgstr ""

#: ../../source/variables_expressions_statements.rst:286
# a4385613442c412183250a5957060a57
msgid "import"
msgstr ""

#: ../../source/variables_expressions_statements.rst:287
# dedc0f4a4a374d269a6663957da91907
msgid "in"
msgstr ""

#: ../../source/variables_expressions_statements.rst:287
# 96cc9926b4db4cf5a910530293210c72
msgid "is"
msgstr ""

#: ../../source/variables_expressions_statements.rst:287
# 6930ccec92c04661a1c47aadb6f257c3
msgid "lambda"
msgstr ""

#: ../../source/variables_expressions_statements.rst:287
# 266872c1f37c43f2bb2b27927023b6bc
msgid "nonlocal"
msgstr ""

#: ../../source/variables_expressions_statements.rst:287
# 24e5dd4bf67543e29544e8f96a3013bf
msgid "not"
msgstr ""

#: ../../source/variables_expressions_statements.rst:287
# 7fe5fe9cbd5b416b97145b855312f557
msgid "or"
msgstr ""

#: ../../source/variables_expressions_statements.rst:288
# 99bdbb541c8648288e3c378df067c062
msgid "pass"
msgstr ""

#: ../../source/variables_expressions_statements.rst:288
# d3944ee11a4e4d6790a36daccfaa879a
msgid "raise"
msgstr ""

#: ../../source/variables_expressions_statements.rst:288
# e457af94bd4843419f112081b08304b1
msgid "return"
msgstr ""

#: ../../source/variables_expressions_statements.rst:288
# 3d73a3f0e7334548ae22465da7c2519c
msgid "try"
msgstr ""

#: ../../source/variables_expressions_statements.rst:288
# cd6960e3afaf43f687b4b4b2ada0f04c
msgid "while"
msgstr ""

#: ../../source/variables_expressions_statements.rst:288
# 810a42e9f11c4e438131cd5097ebb13b
msgid "with"
msgstr ""

#: ../../source/variables_expressions_statements.rst:289
# e423331013ee463a99cf36d646246c19
msgid "yield"
msgstr ""

#: ../../source/variables_expressions_statements.rst:289
# 99aaa25ae94a4f5495bb46c32b8765bd
msgid "True"
msgstr ""

#: ../../source/variables_expressions_statements.rst:289
# fd85b14176594cffa9c8f133cac0d96d
msgid "False"
msgstr ""

#: ../../source/variables_expressions_statements.rst:289
# 5b0326be6bbd4326a513b972b7c3869e
msgid "None"
msgstr ""

#: ../../source/variables_expressions_statements.rst:292
# d1c9cd27939a40ed8c2b6bc88069aa47
msgid "You might want to keep this list handy. If the interpreter complains about one of your variable names and you don't know why, see if it is on this list."
msgstr ""

#: ../../source/variables_expressions_statements.rst:295
# fa3391d2bf4d4799acc361b791476c8b
msgid "Programmers generally choose names for their variables that are meaningful to the human readers of the program --- they help the programmer document, or remember, what the variable is used for."
msgstr ""

#: ../../source/variables_expressions_statements.rst:300
# c511a5f37c1b4c7a87eeb6acba154030
msgid "Beginners sometimes confuse \"meaningful to the human readers\" with \"meaningful to the computer\". So they'll wrongly think that because they've called some variable ``average`` or ``pi``, it will somehow magically calculate an average, or magically know that the variable ``pi`` should have a value like 3.14159.  No! The computer doesn't understand what you intend the variable to mean."
msgstr ""

#: ../../source/variables_expressions_statements.rst:305
# 06870fe72a304e8da77e1c47d358bb06
msgid "So you'll find some instructors who deliberately don't choose meaningful names when they teach beginners --- not because we don't think it is a good habit, but because we're trying to reinforce the message that you --- the programmer --- must write the program code to calculate the average, and you must write an assignment statement to give the variable ``pi`` the value you want it to have."
msgstr ""

#: ../../source/variables_expressions_statements.rst:314
# d05f128336b64fccab6d00c09e3cd175
msgid "Statements"
msgstr ""

#: ../../source/variables_expressions_statements.rst:316
# 375b85c2312e4a88bcecc3be90c2c9ad
msgid "A **statement** is an instruction that the Python interpreter can execute. We have only seen the assignment statement so far.  Some other kinds of statements that we'll see shortly are ``while`` statements, ``for`` statements, ``if`` statements, and ``import`` statements.  (There are other kinds too!)"
msgstr ""

#: ../../source/variables_expressions_statements.rst:321
# 559e8bd099e94048a69027ebcc12a1fc
msgid "When you type a statement on the command line, Python executes it.  Statements don't produce any result."
msgstr ""

#: ../../source/variables_expressions_statements.rst:328
# b3f6a9f28e86468abf29e7f879053c20
msgid "Evaluating expressions"
msgstr ""

#: ../../source/variables_expressions_statements.rst:330
# d51cf51b3b8e4c1885a08178835db77e
msgid "An **expression** is a combination of values, variables, operators, and calls to functions. If you type an expression at the Python prompt, the interpreter **evaluates** it and displays the result:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:341
# dbe8a0bb250240769a4aea47cdef4430
msgid "In this example ``len`` is a built-in Python function that returns the number of characters in a string. We've previously seen the ``print`` and the ``type`` functions, so this is our third example of a function!"
msgstr ""

#: ../../source/variables_expressions_statements.rst:344
# efb24cd6a99942589861757ec8cba061
msgid "The *evaluation of an expression* produces a value, which is why expressions can appear on the right hand side of assignment statements. A value all by itself is a simple expression, and so is a variable."
msgstr ""

#: ../../source/variables_expressions_statements.rst:363
# c6bbd04bc4e74f9da74ac565f9c0d32f
msgid "Operators and operands"
msgstr ""

#: ../../source/variables_expressions_statements.rst:365
# e70f60fb6dc045bd9699e24580a02a54
msgid "**Operators** are special tokens that represent computations like addition, multiplication and division. The values the operator uses are called **operands**."
msgstr ""

#: ../../source/variables_expressions_statements.rst:368
# 0c65e7cbb4b34d7792ea535881d07577
msgid "The following are all legal Python expressions whose meaning is more or less clear::"
msgstr ""

#: ../../source/variables_expressions_statements.rst:373
# a038a2bf340d45eb85da7247518cf846
msgid "The tokens ``+``, ``-``, and ``*``, and the use of parenthesis for grouping, mean in Python what they mean in mathematics. The asterisk (``*``) is the token for multiplication, and ``**`` is the token for exponentiation."
msgstr ""

#: ../../source/variables_expressions_statements.rst:384
# 1eccc32de48646be8b50cf69ac1b11d9
msgid "When a variable name appears in the place of an operand, it is replaced with its value before the operation is performed."
msgstr ""

#: ../../source/variables_expressions_statements.rst:387
# 17fb9921666347a89ae3a5a56970faa9
msgid "Addition, subtraction, multiplication, and exponentiation all do what you expect."
msgstr ""

#: ../../source/variables_expressions_statements.rst:390
# 94f7640346024df6aa76bc9686738a4b
msgid "Example: so let us convert 645 minutes into hours:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:399
# b2effd8877604a8286a55b0fbac67a9a
msgid "Oops! In Python 3, the division operator ``/`` always yields a floating point result. What we might have wanted to know was how many *whole* hours there are, and how many minutes remain. Python gives us two different flavours of the division operator. The second, called **integer division** uses the token ``//``. It always *truncates* its result down to the next smallest integer (to the left on the number line)."
msgstr ""

#: ../../source/variables_expressions_statements.rst:417
# 45d2c40c133e4ab3a2df1bc5fd5b2e08
msgid "Take care that you choose the correct flavour of the division operator.  If you're working with expressions where you need floating point values, use the division operator that does the division accurately."
msgstr ""

#: ../../source/variables_expressions_statements.rst:425
# 90bc7cd9653340c1ab45766f631f5315
msgid "Type converter functions"
msgstr ""

#: ../../source/variables_expressions_statements.rst:427
# 5c9ead4d730543788eaa9da75ee04a80
msgid "Here we'll look at three more Python functions, ``int``, ``float`` and ``str``, which will (attempt to) convert their arguments into types ``int``, ``float`` and ``str`` respectively.  We call these **type converter** functions."
msgstr ""

#: ../../source/variables_expressions_statements.rst:431
# 8b59d02ae0c9459e87588ff7f7f27434
msgid "The ``int`` function can take a floating point number or a string, and turn it into an int. For floating point numbers, it *discards* the decimal portion of the number --- a process we call *truncation towards zero* on the number line.  Let us see this in action:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:454
# 885bcd020018443aa9072264a9e8ea12
msgid "This last case doesn't look like a number --- what do we expect?"
msgstr ""

#: ../../source/variables_expressions_statements.rst:464
# 8f50812b2fd547339d223e1a3b30b118
msgid "The type converter ``float`` can turn an integer, a float, or a syntactically legal string into a float:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:474
# 13c1b3336db74277be94cb4b7579133e
msgid "The type converter ``str`` turns its argument into a string:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:488
# 8888999fe97b4fdfbabc6c5b0b6878af
msgid "Order of operations"
msgstr ""

#: ../../source/variables_expressions_statements.rst:490
# 3e6b558bf1eb4058b270c5c3e40477b9
msgid "When more than one operator appears in an expression, the order of evaluation depends on the **rules of precedence**. Python follows the same precedence rules for its mathematical operators that mathematics does. The acronym PEMDAS is a useful way to remember the order of operations:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:495
# 14960e633de740978bcb3843416bf776
msgid "**P**\\ arentheses have the highest precedence and can be used to force an expression to evaluate in the order you want. Since expressions in parentheses are evaluated first, ``2 * (3-1)`` is 4, and ``(1+1)**(5-2)`` is 8. You can also use parentheses to make an expression easier to read, as in ``(minute * 100) / 60``, even though it doesn't change the result."
msgstr ""

#: ../../source/variables_expressions_statements.rst:500
# 4dffffac2e9b4f428ce998bf190832c9
msgid "**E**\\ xponentiation has the next highest precedence, so ``2**1+1`` is 3 and not 4, and ``3*1**3`` is 3 and not 27."
msgstr ""

#: ../../source/variables_expressions_statements.rst:502
# 6f23afd31cdd4a148cc9315e73be1b03
msgid "**M**\\ ultiplication and both **D**\\ ivision operators have the same precedence, which is higher than **A**\\ ddition and **S**\\ ubtraction, which also have the same precedence. So ``2*3-1`` yields 5 rather than 4, and ``5-2*2`` is 1, not 6."
msgstr ""

#: ../../source/variables_expressions_statements.rst:505
# dbfe7df468a04a448e7944f510ad7ae3
msgid "Operators with the *same* precedence are evaluated from left-to-right. In algebra we say they are *left-associative*.  So in the expression ``6-3+2``, the subtraction happens first, yielding 3. We then add 2 to get the result 5. If the operations had been evaluated from right to left, the result would have been ``6-(3+2)``, which is 1.  (The acronym PEDMAS could mislead you to thinking that division has higher precedence than multiplication, and addition is done ahead of subtraction - don't be misled. Subtraction and addition are at the same precedence, and the left-to-right rule applies.)"
msgstr ""

#: ../../source/variables_expressions_statements.rst:514
# aaea42c5701249d1a9c201756ffe16d4
msgid "Due to some historical quirk, an exception to the left-to-right left-associative rule is the exponentiation operator ``**``, so a useful hint is to always use parentheses to force exactly the order you want when exponentiation is involved:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:525
# 4c9a364c405447bf99e82b8e6d86cd04
msgid "The immediate mode command prompt of Python is great for exploring and experimenting with expressions like this."
msgstr ""

#: ../../source/variables_expressions_statements.rst:531
# 315bc3c0d39347a9b0ae273d755c96db
msgid "Operations on strings"
msgstr ""

#: ../../source/variables_expressions_statements.rst:533
# 061b73b5cf464c1ba164c43297ae2bf0
msgid "In general, you cannot perform mathematical operations on strings, even if the strings look like numbers. The following are illegal (assuming that ``message`` has type string):"
msgstr ""

#: ../../source/variables_expressions_statements.rst:544
# 16362cc0b11f4e818b4ed6be8f49ce20
msgid "Interestingly, the ``+`` operator does work with strings, but for strings, the ``+`` operator represents **concatenation**, not addition. Concatenation means joining the two operands by linking them end-to-end. For example:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:555
# c811a2d2602147cabf4f76a9d7a461f7
msgid "The output of this program is ``banana nut bread``. The space before the word ``nut`` is part of the string, and is necessary to produce the space between the concatenated strings."
msgstr ""

#: ../../source/variables_expressions_statements.rst:559
# 07d189d473df41baa28cf5755faef721
msgid "The ``*`` operator also works on strings; it performs repetition. For example, ``'Fun'*3`` is ``'FunFunFun'``. One of the operands has to be a string; the other has to be an integer."
msgstr ""

#: ../../source/variables_expressions_statements.rst:563
# 714b4a9437cd44238135f65abadb11f3
msgid "On one hand, this interpretation of ``+`` and ``*`` makes sense by analogy with addition and multiplication. Just as ``4*3`` is equivalent to ``4+4+4``, we expect ``\"Fun\"*3`` to be the same as ``\"Fun\"+\"Fun\"+\"Fun\"``, and it is. On the other hand, there is a significant way in which string concatenation and repetition are different from integer addition and multiplication. Can you think of a property that addition and multiplication have that string concatenation and repetition do not?"
msgstr ""

#: ../../source/variables_expressions_statements.rst:577
# 8c8d0734f9474cb9b520fc968c934b61
msgid "Input"
msgstr ""

#: ../../source/variables_expressions_statements.rst:579
# 48f81a7415e7410c8a3a23c544463d09
msgid "There is a built-in function in Python for getting input from the user:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:586
# 07e649bb647f40799e0c310549b5d0c6
msgid "A sample run of this script in PyScripter would pop up a dialog window like this:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:592
# ce31b73b8c7743f6b07e2d30feae7fd6
msgid "The user of the program can enter the name and click `OK`, and when this happens the text that has been entered is returned from the ``input`` function, and in this case assigned to the variable ``n``."
msgstr ""

#: ../../source/variables_expressions_statements.rst:596
# ca4ded4ec21b42a5b52e8ca78b7578af
msgid "Even if you asked the user to enter their age, you would get back a string like ``\"17\"``. It would be your job, as the programmer, to convert that string into a int or a float, using the ``int`` or ``float`` converter functions we saw earlier."
msgstr ""

#: ../../source/variables_expressions_statements.rst:603
# 2537fc64a3b948d9a79824a02bb1ab93
msgid "Composition"
msgstr ""

#: ../../source/variables_expressions_statements.rst:605
# 166887962d574c1caf3bc5d9117dabcd
msgid "So far, we have looked at the elements of a program --- variables, expressions, statements, and function calls --- in isolation, without talking about how to combine them."
msgstr ""

#: ../../source/variables_expressions_statements.rst:608
# 3b2b8bced4564e468fb092e5e1b50d85
msgid "One of the most useful features of programming languages is their ability to take small building blocks and **compose** them into larger chunks."
msgstr ""

#: ../../source/variables_expressions_statements.rst:611
# cc9e9cbbbfa6498fac290c99123ec7dd
msgid "For example, we know how to get the user to enter some input, we know how to convert the string we get into a float, we know how to write a complex expression, and we know how to print values. Let's put these together in a small four-step program that asks the user to input a value for the radius of a circle, and then computes the area of the circle from the formula"
msgstr ""

#: ../../source/variables_expressions_statements.rst:621
# 3d36a96c87c346a9b3b3c88c6463498a
msgid "Firstly, we'll do the four steps one at a time:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:631
# e5f530a338f44fb58253b5385dbefcfc
msgid "Now let's compose the first two lines into a single line of code, and compose the second two lines into another line of code."
msgstr ""

#: ../../source/variables_expressions_statements.rst:640
# 6ea12abc812647b5a5dd1d98f6475d50
msgid "If we really wanted to be tricky, we could write it all in one statement:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:647
# b6cc3d7fac484884afd9bef373e59d9e
msgid "Such compact code may not be most understandable for humans, but it does illustrate how we can compose bigger chunks from our building blocks."
msgstr ""

#: ../../source/variables_expressions_statements.rst:650
# f30e7fefee784fcfa4bc070ae78d85c3
msgid "If you're ever in doubt about whether to compose code or fragment it into smaller steps, try to make it as simple as you can for the human to follow.  My choice would be the first case above, with four separate steps."
msgstr ""

#: ../../source/variables_expressions_statements.rst:659
# 2cde847ba12d4d5993d016ffebe83801
msgid "The modulus operator"
msgstr ""

#: ../../source/variables_expressions_statements.rst:661
# 88c8da6f5f94403f8a2a5aa9d56af20a
msgid "The **modulus operator** works on integers (and integer expressions) and gives the remainder when the first number is divided by the second. In Python, the modulus operator is a percent sign (``%``). The syntax is the same as for other operators. It has the same precedence as the multiplication operator."
msgstr ""

#: ../../source/variables_expressions_statements.rst:675
# 586556dca3984e57a30a997e31941505
msgid "So 7 divided by 3 is 2 with a remainder of 1."
msgstr ""

#: ../../source/variables_expressions_statements.rst:677
# ea22b985860e4ad69957e7dbf07a8db6
msgid "The modulus operator turns out to be surprisingly useful. For example, you can check whether one number is divisible by another---if ``x % y`` is zero, then ``x`` is divisible by ``y``."
msgstr ""

#: ../../source/variables_expressions_statements.rst:681
# e1736b3b1e9243358809af7aa4180aae
msgid "Also, you can extract the right-most digit or digits from a number.  For example, ``x % 10`` yields the right-most digit of ``x`` (in base 10). Similarly ``x % 100`` yields the last two digits."
msgstr ""

#: ../../source/variables_expressions_statements.rst:685
# af024b1d3093457285cc8de4ca7b276c
msgid "It is also extremely useful for doing conversions, say from seconds, to hours, minutes and seconds. So let's write a program to ask the user to enter some seconds, and we'll convert them into hours, minutes, and remaining seconds."
msgstr ""

#: ../../source/variables_expressions_statements.rst:702
# 4e9f12cc538a460593abe52311e1eb73
msgid "Glossary"
msgstr ""

#: ../../source/variables_expressions_statements.rst:707
# a413d22cec2c4a8592d224a028b0cb2a
msgid "A statement that assigns a value to a name (variable). To the left of the assignment operator, ``=``, is a name. To the right of the assignment token is an expression which is evaluated by the Python interpreter and then assigned to the name. The difference between the left and right hand sides of the assignment statement is often confusing to new programmers. In the following assignment:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:718
# 4ac412966bee4532ae7c2bd1e47550b3
msgid "``n`` plays a very different role on each side of the ``=``. On the right it is a *value* and makes up part of the *expression* which will be evaluated by the Python interpreter before assigning it to the name on the left."
msgstr ""

#: ../../source/variables_expressions_statements.rst:724
# e0267c9fbede42bb9a4898be5a617f11
msgid "``=`` is Python's assignment token, which should not be confused with the mathematical comparison operator using the same symbol."
msgstr ""

#: ../../source/variables_expressions_statements.rst:728
# 9364b4fcc27948d6886afed80787a2c5
msgid "The ability to combine simple expressions and statements into compound statements and expressions in order to represent complex computations concisely."
msgstr ""

#: ../../source/variables_expressions_statements.rst:733
# c7d50b66d77d447892211cf0933f1006
msgid "To join two strings end-to-end."
msgstr ""

#: ../../source/variables_expressions_statements.rst:736
# 0687605261f34465b9662849c0817777
msgid "A set of values. The type of a value determines how it can be used in expressions. So far, the types you have seen are integers (``int``), floating-point numbers (``float``), and strings (``str``)."
msgstr ""

#: ../../source/variables_expressions_statements.rst:741
# 58200d17876c466199f562099ece74c1
msgid "To simplify an expression by performing the operations in order to yield a single value."
msgstr ""

#: ../../source/variables_expressions_statements.rst:745
# 119b4d4544504ea5872e12c2a4deddf7
msgid "A combination of variables, operators, and values that represents a single result value."
msgstr ""

#: ../../source/variables_expressions_statements.rst:749
# 6b568e87d2634fd4965f57317fbfcf64
msgid "A Python data type which stores *floating-point* numbers. Floating-point numbers are stored internally in two parts: a *base* and an *exponent*. When printed in the standard format, they look like decimal numbers. Beware of rounding errors when you use ``float``\\ s, and remember that they are only approximate values."
msgstr ""

#: ../../source/variables_expressions_statements.rst:756
# 720d99693d244fed83aff9e353c7913b
msgid "A Python data type that holds positive and negative whole numbers."
msgstr ""

#: ../../source/variables_expressions_statements.rst:759
# 581327c747334bb5a53f30223920352c
msgid "An operation that divides one integer by another and yields an integer. Integer division yields only the whole number of times that the numerator is divisible by the denominator and discards any remainder."
msgstr ""

#: ../../source/variables_expressions_statements.rst:764
# fbc55a19e9e3412980964e18ed47ca1e
msgid "A reserved word that is used by the compiler to parse program; you cannot use keywords like ``if``, ``def``, and ``while`` as variable names."
msgstr ""

#: ../../source/variables_expressions_statements.rst:769
# 0fb526f12cbe451d990c8e9eb221c440
msgid "An operator, denoted with a percent sign ( ``%``), that works on integers and yields the remainder when one number is divided by another."
msgstr ""

#: ../../source/variables_expressions_statements.rst:774
# 47cac4d817344810a092166dcb6870b1
msgid "One of the values on which an operator operates."
msgstr ""

#: ../../source/variables_expressions_statements.rst:777
# 6b19399dadf24909a2af88aa4e39653b
msgid "A special symbol that represents a simple computation like addition, multiplication, or string concatenation."
msgstr ""

#: ../../source/variables_expressions_statements.rst:781
# 6709269e97df4f35b2eb2daabc51cd03
msgid "The set of rules governing the order in which expressions involving multiple operators and operands are evaluated."
msgstr ""

#: ../../source/variables_expressions_statements.rst:785
# 3b76483aa5c8407baf4d814d7d4292ac
msgid "A graphical representation of a set of variables and the values to which they refer, taken at a particular instant during the program's execution."
msgstr ""

#: ../../source/variables_expressions_statements.rst:789
# 98978d6047af48068410cf0c581aadd0
msgid "An instruction that the Python interpreter can execute.  So far we have only seen the assignment statement, but we will soon meet the ``import`` statement and the ``for`` statement."
msgstr ""

#: ../../source/variables_expressions_statements.rst:794
# 0153ddc4bb0f452cb09d0adfe3f38871
msgid "A Python data type that holds a string of characters."
msgstr ""

#: ../../source/variables_expressions_statements.rst:797
# 9ab96fdd803b4f158fb25f2a1afac997
msgid "A number or string (or other things to be named later) that can be stored in a variable or computed in an expression."
msgstr ""

#: ../../source/variables_expressions_statements.rst:801
# e7bb8b024ef8418086548b7e0a0d069f
msgid "A name that refers to a value."
msgstr ""

#: ../../source/variables_expressions_statements.rst:804
# 90a54092755d4a02a17d9c5970a4a029
msgid "A name given to a variable. Variable names in Python consist of a sequence of letters (a..z, A..Z, and _) and digits (0..9) that begins with a letter.  In best programming practice, variable names should be chosen so that they describe their use in the program, making the program *self documenting*."
msgstr ""

#: ../../source/variables_expressions_statements.rst:812
# 5c2c2b1e8c6644948b9693b3fc5ca293
msgid "Exercises"
msgstr ""

#: ../../source/variables_expressions_statements.rst:815
# 4ee9d1ef820b44b6b2b99725c68ccb29
msgid "Take the sentence: *All work and no play makes Jack a dull boy.* Store each word in a separate variable, then print out the sentence on one line using ``print``."
msgstr ""

#: ../../source/variables_expressions_statements.rst:818
# c6e3fa1af3224532aec506bc7a7d9167
msgid "Add parenthesis to the expression ``6 * 1 - 2`` to change its value from 4 to -6."
msgstr ""

#: ../../source/variables_expressions_statements.rst:820
# 33b575b7979e4f2b915b88d777033092
msgid "Place a comment before a line of code that previously worked, and record what happens when you rerun the program."
msgstr ""

#: ../../source/variables_expressions_statements.rst:822
# 8879c5aac1214a1c87db5ea5c96f734c
msgid "Start the Python interpreter and enter ``bruce + 4`` at the prompt. This will give you an error:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:829
# 38174976d7d04e299af0ddb9f6708730
msgid "Assign a value to ``bruce`` so that ``bruce + 4`` evaluates to ``10``."
msgstr ""

#: ../../source/variables_expressions_statements.rst:830
# c0bc6a155cec42a6a02dd3490bd7ce41
msgid "The formula for computing the final amount if one is earning compound interest is given on Wikipedia as"
msgstr ""

#: ../../source/variables_expressions_statements.rst:836
# c71dbf9e2fc24ac7919cdc74e6780685
msgid "Write a Python program that assigns the principal amount of R10000 to variable `p`, assign to `n` the value 12, and assign to `r` the interest rate of 8%. Then have the program prompt the user for the number of months `t` that the money will be compounded for.  Calculate and print the final amount after `t` months."
msgstr ""

#: ../../source/variables_expressions_statements.rst:841
# 011c319d84b84a42a74d2ae12b55d0e2
msgid "Evaluate the following numerical expressions in your head, then use the Python interpreter to check your results:"
msgstr ""

#: ../../source/variables_expressions_statements.rst:844
# 8b7583e3c9ec4fabad8d9e2a3a6c2c6e
msgid "``>>> 5 % 2``"
msgstr ""

#: ../../source/variables_expressions_statements.rst:845
# e9e363cd0e664c5581a3c4d21b79dd9b
msgid "``>>> 9 % 5``"
msgstr ""

#: ../../source/variables_expressions_statements.rst:846
# cd8d319440a94721b64bceba2807e8d5
msgid "``>>> 15 % 12``"
msgstr ""

#: ../../source/variables_expressions_statements.rst:847
# a3c662a746d24ef7aca6b47a47264d62
msgid "``>>> 12 % 15``"
msgstr ""

#: ../../source/variables_expressions_statements.rst:848
# dba1ae9c15314aad9ad68f77de2850f2
msgid "``>>> 6 % 6``"
msgstr ""

#: ../../source/variables_expressions_statements.rst:849
# 0f1fe978b1a94e21a14eeb207d2d6eca
msgid "``>>> 0 % 7``"
msgstr ""

#: ../../source/variables_expressions_statements.rst:850
# baa22b8c0b5f444e8ff19492792f1165
msgid "``>>> 7 % 0``"
msgstr ""

#: ../../source/variables_expressions_statements.rst:852
# 19f72abb80744019818c60c06b793b7b
msgid "What happened with the last example? Why? If you were able to correctly anticipate the computer's response in all but the last one, it is time to move on. If not, take time now to make up examples of your own. Explore the modulus operator until you are confident you understand how it works."
msgstr ""

#: ../../source/variables_expressions_statements.rst:857
# 467cfb649965477c8f1a5a7e8fa64c42
msgid "You look at the clock and it is exactly 2pm.  You set an alarm to go off in 51 hours.  At what time does the alarm go off?  (Hint: you could count on your fingers, but this is not what we're after.  If you are tempted to count on your fingers, change the 51 to 5100.)"
msgstr ""

#: ../../source/variables_expressions_statements.rst:862
# f534fabe3c164292a056e65f2d10a768
msgid "Write a Python program to solve the general version of the above problem. Ask the user for the time now (in hours), and ask for the number of hours to wait. Your program should output what the time will be on the clock when the alarm goes off."
msgstr ""

